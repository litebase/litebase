
#include "./litebasedb_vfs.h"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

extern int goXOpen(sqlite3_vfs *vfs, const char *name, sqlite3_file *file, int flags, int *outFlags);
extern int goXRead(sqlite3_file *file, void *buf, int iAmt, sqlite3_int64 iOfst);
extern int goXWrite(sqlite3_file *file, const void *buf, int iAmt, sqlite3_int64 iOfst);
extern int goXFileSize(sqlite3_file *file, sqlite3_int64 *pSize);

static struct
{
  /* The pOrigVfs is the real, original underlying VFS implementation.
   ** Most operations pass-through to the real VFS.  This value is read-only
   ** during operation.  It is only modified at start-time and thus does not
   ** require a mutex.
   */
  sqlite3_vfs *pOrigVfs;

  /* The sThisVfs is the VFS structure used by this shim.  It is initialized
  ** at start-time and thus does not require a mutex
  */
  sqlite3_vfs sThisVfs;

  /* The sIoMethods defines the methods used by sqlite3_file objects
  ** associated with this shim.  It is initialized at start-time and does
  ** not require a mutex.
  **
  ** When the underlying VFS is called to open a file, it might return
  ** either a version 1 or a version 2 sqlite3_file object.  This shim
  ** has to create a wrapper sqlite3_file of the same version.  Hence
  ** there are two I/O method structures, one for version 1 and the other
  ** for version 2.
  */
  sqlite3_io_methods sIoMethodsV1;
  sqlite3_io_methods sIoMethodsV2;

  /* True when this shim as been initialized.
   */
  int isInitialized;

  /* For run-time access any of the other global data structures in this
  ** shim, the following mutex must be held.
  */
  sqlite3_mutex *pMutex;
} lbdb;

static sqlite3_vfs *lbdbRootVFS() { return lbdb.pOrigVfs; }

/* Translate an sqlite3_file* that is really a LBDBFile* into
** the sqlite3_file* for the underlying original VFS.
*/
static sqlite3_file *lbdbFile(sqlite3_file *pFile)
{
  LBDBFile *p = (LBDBFile *)pFile;

  return (sqlite3_file *)&p[1];
}

int lbdbRead(sqlite3_file *pFile, void *zBuf, int iAmt, sqlite3_int64 iOfst)
{
  // LBDBFile *connection = (LBDBFile *)pFile;
  // // printf("Read: %s\n", connection->main ? "main" : "wal");

  // if (connection->main == 0)
  // {
  //   return lbdbFile(pFile)->pMethods->xRead(lbdbFile(pFile), zBuf, iAmt, iOfst);
  // }

  return goXRead(pFile, zBuf, iAmt, iOfst);
}

int lbdbWrite(sqlite3_file *pFile, const void *zBuf, int iAmt, sqlite3_int64 iOfst)
{
  return goXWrite(pFile, zBuf, iAmt, iOfst);
}

// truncate
int lbdbTruncate(sqlite3_file *pFile, sqlite3_int64 size)
{
  return lbdbFile(pFile)->pMethods->xTruncate(lbdbFile(pFile), size);
}

int lbdbSync(sqlite3_file *pFile, int flags)
{
  return lbdbFile(pFile)->pMethods->xSync(lbdbFile(pFile), flags);
}

int lbdbFileSize(sqlite3_file *pFile, sqlite3_int64 *pSize)
{
  return goXFileSize(pFile, pSize);
}

int lbdbLock(sqlite3_file *pFile, int eLock)
{
  return lbdbFile(pFile)->pMethods->xLock(lbdbFile(pFile), eLock);
}

int lbdbUnlock(sqlite3_file *pFile, int eLock)
{
  return lbdbFile(pFile)->pMethods->xUnlock(lbdbFile(pFile), eLock);
}

int lbdbCheckReservedLock(sqlite3_file *pFile, int *pResOut)
{
  return lbdbFile(pFile)->pMethods->xCheckReservedLock(lbdbFile(pFile),
                                                       pResOut);
}

int lbdbFileControl(sqlite3_file *pFile, int op, void *pArg)
{
  return lbdbFile(pFile)->pMethods->xFileControl(lbdbFile(pFile), op, pArg);
}

int lbdbSectorSize(sqlite3_file *pFile)
{
  return lbdbFile(pFile)->pMethods->xSectorSize(lbdbFile(pFile));
}

int lbdbDeviceCharacteristics(sqlite3_file *pFile)
{
  return lbdbFile(pFile)->pMethods->xDeviceCharacteristics(lbdbFile(pFile));
}

int lbdbShmMap(sqlite3_file *pFile, int iPg, int pgsz, int x, void volatile **pp)
{
  return lbdbFile(pFile)->pMethods->xShmMap(lbdbFile(pFile), iPg, pgsz, x, pp);
}

int lbdbShmLock(sqlite3_file *pFile, int offset, int n, int flags)
{
  return lbdbFile(pFile)->pMethods->xShmLock(lbdbFile(pFile), offset, n, flags);
}

void lbdbShmBarrier(sqlite3_file *pFile)
{
  lbdbFile(pFile)->pMethods->xShmBarrier(lbdbFile(pFile));
}

int lbdbShmUnmap(sqlite3_file *pFile, int deleteFlag)
{
  return lbdbFile(pFile)->pMethods->xShmUnmap(lbdbFile(pFile), deleteFlag);
}

int lbdbOpen(sqlite3_vfs *pVfs, const char *zName, sqlite3_file *pFile, int flags, int *pOutFlags)
{
  int rc;

  if ((flags & SQLITE_OPEN_MAIN_DB) == 0)
  {
    return lbdbRootVFS()->xOpen(pVfs, zName, pFile, flags, pOutFlags);
  }

  LBDBFile *connection = (LBDBFile *)pFile;
  sqlite3_file *file = lbdbFile(pFile);

  rc = goXOpen(lbdbRootVFS(), zName, pFile, flags, pOutFlags);
  // // printf("__Open__: %d\n", file->pMethods);
  // if (pFile->pMethods->iVersion == 1)
  // {
  //   connection->base.pMethods = &lbdb.sIoMethodsV1;
  // }
  // else
  // {
  //   connection->base.pMethods = &lbdb.sIoMethodsV2;
  // }

  return rc;
}

int lbdbDelete(sqlite3_vfs *pVfs, const char *zName, int syncDir)
{
  return lbdbRootVFS()->xDelete(pVfs, zName, syncDir);
}

int lbdbAccess(sqlite3_vfs *pVfs, const char *zName, int flags, int *pResOut)
{
  return lbdbRootVFS()->xAccess(pVfs, zName, flags, pResOut);
}

int lbdbClose(sqlite3_file *pFile)
{
  return lbdbFile(pFile)->pMethods->xClose(lbdbFile(pFile));
}

int register_litebasedb_vfs()
{
  sqlite3_vfs *pOrigVfs;

  if (lbdb.isInitialized)
  {
    return SQLITE_MISUSE;
  }

  pOrigVfs = sqlite3_vfs_find(NULL);

  if (pOrigVfs == 0)
  {
    return SQLITE_ERROR;
  }

  assert(pOrigVfs != &lbdb.sThisVfs);

  lbdb.pMutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);

  if (!lbdb.pMutex)
  {
    return SQLITE_NOMEM;
  }

  lbdb.isInitialized = 1;
  lbdb.pOrigVfs = pOrigVfs;
  lbdb.sThisVfs = *pOrigVfs;
  lbdb.sThisVfs.xOpen = lbdbOpen;
  lbdb.sThisVfs.xDelete = lbdbDelete;
  lbdb.sThisVfs.xAccess = lbdbAccess;
  lbdb.sThisVfs.szOsFile += sizeof(LBDBFile);
  lbdb.sThisVfs.zName = "litebasedb";
  lbdb.sIoMethodsV1.iVersion = 1;
  lbdb.sIoMethodsV1.xClose = lbdbClose;
  lbdb.sIoMethodsV1.xRead = lbdbRead;
  lbdb.sIoMethodsV1.xWrite = lbdbWrite;
  lbdb.sIoMethodsV1.xTruncate = lbdbTruncate;
  lbdb.sIoMethodsV1.xSync = lbdbSync;
  lbdb.sIoMethodsV1.xFileSize = lbdbFileSize;
  lbdb.sIoMethodsV1.xLock = lbdbLock;
  lbdb.sIoMethodsV1.xUnlock = lbdbUnlock;
  lbdb.sIoMethodsV1.xCheckReservedLock = lbdbCheckReservedLock;
  lbdb.sIoMethodsV1.xFileControl = lbdbFileControl;
  lbdb.sIoMethodsV1.xSectorSize = lbdbSectorSize;
  lbdb.sIoMethodsV1.xDeviceCharacteristics = lbdbDeviceCharacteristics;
  lbdb.sIoMethodsV2 = lbdb.sIoMethodsV1;
  lbdb.sIoMethodsV2.iVersion = 2;
  lbdb.sIoMethodsV2.xShmMap = lbdbShmMap;
  lbdb.sIoMethodsV2.xShmLock = lbdbShmLock;
  lbdb.sIoMethodsV2.xShmBarrier = lbdbShmBarrier;
  lbdb.sIoMethodsV2.xShmUnmap = lbdbShmUnmap;

  sqlite3_vfs_register(&lbdb.sThisVfs, 1);

  return SQLITE_OK;
}

void errorLogCallback(void *pArg, int iErrCode, const char *zMsg)
{
  fprintf(stderr, "(%d) %s\n", iErrCode, zMsg);
}

int newVfs()
{
  sqlite3_config(SQLITE_CONFIG_LOG, errorLogCallback, NULL);

  return register_litebasedb_vfs();
}
